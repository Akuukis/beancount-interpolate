__author__ = 'Akuukis <akuukis@kalvis.lv'

import datetime
import re
import math

from beancount.core.amount import Amount, add, sub, mul, div
from beancount.core import data
from beancount.core.position import Position
from beancount.core.number import ZERO, D, round_to

__plugins__ = ['spread']

def get_postings(duration, closing_dates, account, posting, entry, MIN_VALUE):
    new_transactions = []

    ## Distribute value over points. TODO: add new methods
    if(posting.units.number > 0):
        amountEach = math.floor(posting.units.number / duration * 100) / D(str(100))
    else:
        amountEach = math.ceil(posting.units.number / duration * 100) / D(str(100))
    if(abs(amountEach) < abs(MIN_VALUE)):
        amountEach = MIN_VALUE
        duration = math.floor( abs(posting.units.number) / MIN_VALUE )
        closing_dates = closing_dates[0:duration]
    remainder = sub(posting.units, Amount( amountEach * duration, posting.units.currency) )

    ## Debug
    # print('      Extend %s over %s points %s per each (%s remainder).'%(posting.units, countTransactions, amountEach, remainder))

    ## Double-check leg direction
    if(posting.units.number > 0):
        assert(remainder > Amount(D(str(-0.01)), posting.units.currency))
    else:
        assert(remainder < Amount(D(str(+0.01)), posting.units.currency))

    ## Generate new transactions
    for i, _ in enumerate(closing_dates):
        ## Debug
        # print(amountEach, closing_dates[i], i)

        ## Add remainder to first day.
        if(i == 0):
            amount = add(Amount(D(amountEach), posting.units.currency), remainder)
        else:
            amount = Amount(D(amountEach), posting.units.currency)

        # Income/Expense to be spread
        p1 = data.Posting(account=posting.account,
                          units=amount,
                          cost=None,
                          price=None,
                          flag=None,
                          meta=None)

        # Asset/Liability that buffers the difference
        p2 = data.Posting(account=account,
                          units=mul(amount, D(-1)),
                          cost=None,
                          price=None,
                          flag=None,
                          meta=None)

        e = data.Transaction(date=closing_dates[i],
                             meta=entry.meta,
                             flag='*',
                             payee=entry.payee,
                             narration=entry.narration + ' (Generated by interpolate-spread %d/%d)'%(i+1, duration), # TODO: SUFFIX
                             tags={'spread'}, # TODO: TAG
                             links=entry.links,
                             postings=[p1, p2])
        new_transactions.append(e)
    return new_transactions


def get_params(aliases, entry, posting):
    for alias in aliases:
        if hasattr(posting, 'meta') and alias in posting.meta:
            return posting.meta[alias]
        if hasattr(entry, 'meta') and alias in entry.meta:
            return entry.meta[alias]
        if hasattr(entry, 'tags') and hasattr(entry.tags, alias):
            return ''
    return False


def spread(entries, options_map, config_string):
    """Add depreciation entries for fixed assets.  See module docstring for more
    details and example"""
    errors = []

    ## Parse config and set defaults
    config_obj = eval(config_string, {}, {})
    if not isinstance(config_obj, dict):
        raise RuntimeError("Invalid plugin configuration: should be a single dict.")
    ACCOUNT_INCOME   = config_obj.pop('account_income'  , 'Liabilities:Current')
    ACCOUNT_EXPENSES = config_obj.pop('account_expenses', 'Assets:Current')
    ALIASES_BEFORE   = config_obj.pop('aliases_before'  , ['spreadBefore'])
    ALIASES_AFTER    = config_obj.pop('aliases_after'   , ['spreadAfter', 'spread'])
    DEFAULT_PERIOD   = config_obj.pop('default_period'  , 'Month')
    DEFAULT_METHOD   = config_obj.pop('default_method'  , 'SL')
    MIN_VALUE        = config_obj.pop('min_value'       , 0.05)
    MAX_NEW_TX       = config_obj.pop('max_new_tx'      , 9999)
    SUFFIX           = config_obj.pop('suffix'          , ' (Generated by interpolate-spread)')
    TAG              = config_obj.pop('tag'             , 'spread')
    MIN_VALUE = D(str(MIN_VALUE))

    ## Filter transaction entries that have tag or meta or its posting has meta.
    newEntries = []
    for i, entry in enumerate(entries):
        if hasattr(entry, 'postings'):
            for j, p in enumerate(entry.postings):
                params = get_params(ALIASES_AFTER, entry, p)  # TODO: ALIASES_BEFORE
                if not params:
                    continue

                ## Debug
                # print('L%4d Posting #%d-%d'%(int(p.meta['lineno']), i, j), p)

                ## Modify original entry to replace Income/Expense with Liability/Asset
                account = p.account.split(':')
                if(account[0] == 'Income'):
                    side = ACCOUNT_INCOME
                elif(account[0] == 'Expenses'):
                    side = ACCOUNT_EXPENSES
                else:
                    continue ## Filter out non-Income/Expense postings.
                account.pop(0)
                account.insert(0, side)
                account = ':'.join(account)
                entry.postings.pop(j)
                entry.postings.insert(j, data.Posting(
                    account=account,
                    units=Amount(p.units.number, p.units.currency),
                    cost=None,
                    price=None,
                    flag=None,
                    meta=None))

                # Infer Duration, start and steps. Format: [123|KEYWORD] [@ YYYY-MM-DD]
                parts = re.findall("^(\s*?(\S+))?\s*?(@\s*?([0-9]{4})-([0-9]{2})-([0-9]{2}))?\s*?$", params)[0]
                try:
                    start = datetime.date(int(parts[3]), int(parts[4]), int(parts[5]))
                except:
                    start = entry.date
                try: # TODO: DEFAULT_PERIOD
                    duration = int(parts[0])
                except:
                    dictionary = {
                        'Day': 1,
                        'Week': 7,
                        'Month': 30,
                        'Year': 365
                    }
                    duration = dictionary[parts[0]]

                if(duration<=366):  # TODO: MAX_NEW_TX
                    step = 1
                else:
                    step = 1

                # Stretch over time
                closing_dates = []
                d = start
                while d < start + datetime.timedelta(days=duration) and d <= datetime.date.today():
                    closing_dates.append(d)
                    d = d + datetime.timedelta(days=step)

                # print(params, entry)
                if len(closing_dates) > 0:
                    newEntries = newEntries + get_postings(duration, closing_dates, account, p, entry, MIN_VALUE)

    return entries + newEntries, errors


def get_new_dates(begin_date, duration):
    """Given a begin_date, find out all dates until today"""